# FIPS Auditing Anti-patterns

| Anti-Pattern                                        | Description                                                                                             | FIPS Compliance Issue                                                                                            | Example                                                                                                                                                                                                   | Remediation                                                                                                                                                                                                                              |
| --------------------------------------------------- | ------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Non-FIPS Approved Algorithms**                    | Using algorithms not listed in FIPS-approved standards.                                                 | Direct violation, making system non-compliant.                                                                   | Using **DES, RC4, MD5, SHA-1 (for signatures)**, Skipjack, Blowfish, or RC2 directly for cryptographic operations.                                                                                        | Replace with **AES, SHA-2 (SHA-224, SHA-256, SHA-384, SHA-512), SHA-3, or approved KDFs like PBKDF2 or Argon2.**                                                                                                                         |
| **Inadequate Key Lengths**                          | Using key lengths below minimum FIPS requirements.                                                      | Insufficient security, vulnerable to attacks.                                                                    | Using **RSA with keys less than 2048 bits, HMAC keys less than 112 bits for generation, AES keys less than 128 bits**, or **Diffie-Hellman with keys less than 2048 bits**.                               | Use minimum key sizes: **128-bit for AES, 2048-bit for RSA (4096 or higher recommended), 112-bit for HMAC, 224 bit for elliptic curves and 2048-bit for DH.**                                                                            |
| **Legacy Algorithms Usage**                         | Using algorithms considered legacy/deprecated for new apps.                                             | Allowed only for existing data, not new encryption.                                                              | Using **two-key TDEA for encryption, SHA-1 for digital signature generation**, or **3DES for encryption**.                                                                                                | Migrate to current: **AES for encryption, SHA-2/SHA-3 for hashing, avoid two-key TDEA, and prefer AES over 3DES.**                                                                                                                       |
| **Disallowed Algorithms Usage**                     | Employing algorithms explicitly prohibited by FIPS.                                                     | Clear violation, system is non-compliant.                                                                        | Using **three-key TDEA after 2023 for encryption, DUAL_EC_DRBG for random number generation.**                                                                                                            | Switch to approved algorithms.                                                                                                                                                                                                           |
| **Insecure Block Cipher Modes**                     | Using non-approved or vulnerable block cipher modes.                                                    | Compromises confidentiality & integrity.                                                                         | Using **CBC mode without proper integrity checks (e.g., MAC), ECB mode**, or **non-authenticated modes for encryption.**                                                                                  | Use authenticated encryption modes like **GCM or CCM.** For CBC, ensure proper integrity checks (e.g., using HMAC) or prefer authenticated encryption modes.                                                                             |
| **Improper Padding**                                | Incorrectly padding data in block cipher modes.                                                         | Allows padding oracle attacks, leaks plaintext.                                                                  | Using **PKCS#1 v1.5 with RSA encryption**, or not correctly using padding in CBC modes leading to padding oracle attacks.                                                                                 | Use **OAEP padding with RSA**, or use authenticated encryption. Ensure proper padding verification during decryption.                                                                                                                    |
| **Weak Password Hashing**                           | Using weak/non-FIPS approved methods for password hashing.                                              | Increases vulnerability to password cracking.                                                                    | Using **unsalted SHA-512, MD5 or SHA-1 for password hashing**, single iteration hash, or using a weaker hash function for password storage.                                                               | Use **PBKDF2** with strong hash (SHA-256/SHA-512), high iteration count (at least 10,000), and a unique salt. Consider **Argon2, scrypt, or bcrypt** (though not strictly FIPS-approved) if FIPS compliance is not a strict requirement. |
| **Insecure Key Storage**                            | Storing keys insecurely, non-FIPS compliant.                                                            | Exposes private keys, enables unauthorized access.                                                               | Storing keys in **JKS keystores (weak encryption)**, as ASCII strings, hardcoding keys, or using weak key derivation functions.                                                                           | Use **FIPS-compliant BCFKS keystores** with strong encryption. Ensure key material is generated with approved random generators, stored securely, and not hardcoded. Use strong key derivation functions.                                |
| **`java.util.Random` Usage**                        | Using non-secure random number generator in Java.                                                       | Generates predictable random values, compromises security.                                                       | Generating keys or salts with `java.util.Random` instead of SecureRandom.                                                                                                                                 | Use `java.security.SecureRandom` or a FIPS-approved random bit generator.                                                                                                                                                                |
| **Improper Key Reuse**                              | Reusing single key for multiple crypto operations.                                                      | Compromises confidentiality & integrity.                                                                         | Same key for encryption and MAC, key agreement and encryption, or reusing an IV for multiple encryptions.                                                                                                 | Use each key for _one_ crypto operation. Use metadata for key roles where possible. Ensure unique IV's for each encryption.                                                                                                              |
| **Non-Compliant Key Agreement**                     | Using key agreement schemes with non-compliant parameters.                                              | Can lead to key compromise, insecure communications.                                                             | Using **Diffie-Hellman (DH) with key lengths less than 2048-bits, or unsafe groups.** Not using SP 800-56A compliant schemes.                                                                             | Use approved safe-prime groups, and **FIPS 186-type domain parameters with minimum 112-bit security strength** for DH and MQV.                                                                                                           |
| **Incorrect RSA Key Generation**                    | Generating RSA keys without following FIPS guidelines.                                                  | Leads to vulnerable keys.                                                                                        | Not ensuring key generation happens through a validated module, not using a cryptographically strong pseudorandom source, or approved KDF with good entropy. Generating keys without prime generation.    | Generate RSA keys per **FIPS 186-5, using prime generation** using validated modules and secure random number generators. Ensure use of approved KDFs.                                                                                   |
| **Non-FIPS Module Usage**                           | Crypto operations outside of FIPS-validated module.                                                     | Operations outside are not certified.                                                                            | Calling a hash function without using the FIPS mode of a module, using non-fips providers even when a FIPS compliant provider is included, or using non-FIPS implementations of cryptographic algorithms. | Ensure _all_ crypto operations occur _within_ the FIPS-validated boundary in the correct FIPS mode.                                                                                                                                      |
| **Bypass Issues**                                   | Using bypass mechanisms without required integrity checks.                                              | Could expose data in plaintext when encryption is intended.                                                      | Switching between encrypted/non-encrypted services without policy table verification, or allowing a bypass without proper MAC verification.                                                               | Use **MAC or signature verification** on policy table before changes. Apply integrity checks before enabling bypasses.                                                                                                                   |
| **Insecure TLS Configurations**                     | TLS configurations allow weak/non-compliant cipher suites.                                              | Can lead to vulnerabilities in secure connections.                                                               | Using non-FIPS compliant cipher suites with TLS, enabling weak ciphers, or not configuring TLS correctly.                                                                                                 | Use only FIPS-approved cipher suites supported by the FIPS provider. Use TLS 1.3 or higher, and configure for strong ciphers and key exchange algorithms.                                                                                |
| **MD5 for Security Functions**                      | Using MD5 for any security-relevant purpose.                                                            | MD5 is not collision-resistant and is dangerous for security.                                                    | Using **MD5 to create CSRF tokens, password hashing, or for digital signatures**.                                                                                                                         | Replace all MD5 usages for security. Non-security uses _may_ be justifiable to auditors.                                                                                                                                                 |
| **Insufficient Entropy**                            | Using weak sources for random number generation or key derivation.                                      | Compromises the unpredictability of cryptographic keys and other security parameters.                            | Seeding a random number generator with system time, using a predictable source for random values, or reusing a small amount of entropy.                                                                   | Use a FIPS approved random number generator (`java.security.SecureRandom`) and ensure that it is properly seeded with a high-quality entropy source.                                                                                     |
| **Hardcoded Keys/Secrets**                          | Storing cryptographic keys or secrets directly in the source code or configuration files.               | Exposes sensitive information to unauthorized users.                                                             | Including a key as a string in the source code, or committing key files to a repository.                                                                                                                  | Key material should be generated by a cryptographically secure random generator, and then securely stored in a FIPS compliant way and never committed to code repositories.                                                              |
| **Insufficient Iterations**                         | Using low iteration counts in password-based key derivation functions such as PBKDF2.                   | Makes it easier to crack passwords through brute-force attacks.                                                  | Setting the iteration count to less than 10,000 in PBKDF2, or not using proper derivation functions.                                                                                                      | Use a minimum of 10,000 iterations for PBKDF2. Higher iteration counts should be preferred if the performance allows it, and use proper derivation functions such as PBKDF2 or Argon2.                                                   |
| **Not Using Salt**                                  | Not using a unique, randomly generated salt with password hashing or key derivation.                    | Makes passwords vulnerable to pre-computed attacks.                                                              | Storing passwords with only the hash function applied, but without adding a unique salt, or reusing a salt.                                                                                               | Generate a unique random salt for each password and store the salt along with the password hash. Use a unique salt for each key derivation.                                                                                              |
| **Using ECB Mode**                                  | Employing Electronic Codebook mode with block ciphers.                                                  | Leads to repeating patterns which reveals the underlying information.                                            | Encrypting sensitive data with AES or other block cipher using ECB Mode, and encrypting multiple blocks of data with the same key and initialization vector.                                              | Use authenticated encryption modes, such as GCM, or a randomized mode, such as CBC with a unique IV.                                                                                                                                     |
| **Not Using Authenticated Encryption**              | Using an encryption algorithm without proper authentication.                                            | Can lead to data tampering, which is not detectable in confidentiality-only modes.                               | Encrypting sensitive data with a cipher mode that does not have integrity protection, such as CBC.                                                                                                        | Use an authenticated encryption algorithm or mode such as GCM, CCM or EAX which combines encryption and integrity protection in one operation, and use MACs for integrity verification.                                                  |
| **Using Insecure PBEs**                             | Using password-based encryption schemes that have known weaknesses or vulnerabilities.                  | Exposes encrypted data, makes it vulnerable to attacks.                                                          | Using **PKCS#5v1.5 with MD2, MD5, or SHA-1 for key derivation, RC2 or DES for encryption**. Using PBEs with weak keys and short salts.                                                                    | Use more secure PBE schemes with **PBKDF2 and AES** with strong key lengths, high iteration count, and a strong random salt.                                                                                                             |
| **Missing Self Tests**                              | Not performing self-tests on all implemented cryptographic algorithms before the first operational use. | Can lead to issues with algorithm correctness.                                                                   | Using cryptographic algorithms without performing known-answer tests (KATs) at startup, or using algorithms without proper testing.                                                                       | Implement self tests for cryptographic algorithms at power up, or when they are first used, using the smallest approved key length or modulus size. Use self tests at regular intervals.                                                 |
| **Using Non-Standard Curves**                       | Using non-approved elliptic curves in elliptic curve cryptography.                                      | May not provide the expected security strength.                                                                  | Using non-standard elliptic curves with ECDSA, EdDSA, ECDH, or ECDMQV.                                                                                                                                    | Use only the approved elliptic curves as specified in standards, like the curves listed in the Digital Signature Standard.                                                                                                               |
| **Using non-approved MAC algorithms**               | Employing MAC algorithm that has known vulnerabilities.                                                 | Can lead to data tampering and other security issues.                                                            | Using CBC-MAC, ISO 9797 alg 3 with 3DES, or not using a well established and vetted MAC algorithm.                                                                                                        | Prefer CMAC or GMAC, and other well-studied MAC algorithms. Avoid algorithms with known attacks or key recovery issues.                                                                                                                  |
| **Insufficient Crypto Period**                      | Using cryptographic keys for too long of a period of time, and not rotating keys.                       | If a key is compromised at some point during its lifetime, all data encrypted with that key will be compromised. | Using keys with a lifetime that is longer than the specified crypto period, not rotating keys periodically, or not ensuring key lifetimes comply with recommendations.                                    | Ensure the keys are rotated based on time limits, or usage limits defined by an organization or standard. The crypto period of a key should be defined based on the sensitivity of the data that is protected.                           |
| **Incorrect IV Usage**                              | Incorrect use of Initialization Vectors.                                                                | Can lead to predictability and vulnerabilities.                                                                  | Reusing IVs, generating them in a predictable way or using weak sources.                                                                                                                                  | Ensure IVs are generated randomly, and are unique.                                                                                                                                                                                       |
| **Using `java.lang.Math.random()`**                 | Using `java.lang.Math.random()` for security purposes.                                                  | Generates predictable random values, compromises security.                                                       | Using `java.lang.Math.random()` when generating keys, nonces, salts, or any security sensitive values.                                                                                                    | Use `java.security.SecureRandom` or a FIPS-approved random bit generator.                                                                                                                                                                |
| **Not specifying the entire transformation string** | Not specifying the entire transformation string in ciphers.                                             | May use an insecure default or may not use the correct algorithm or mode of operation                            | Using `Cipher.getInstance("AES")` instead of `Cipher.getInstance("AES/GCM/NoPadding")` .                                                                                                                  | Always specify the complete transformation string when using ciphers, including the algorithm, mode of operation, and padding scheme.                                                                                                    |

**Misuse Scenarios:**

- **Custom Seed with SecureRandom**: Using `SecureRandom` but then explicitly setting a weak or predictable seed.
    - _Remedy:_ Let `SecureRandom` manage its own seeding, or provide a high entropy seed.
- **Incorrectly Setting Up Providers**: Adding a third-party provider but not ensuring it has higher precedence than default providers or not ensuring it is inserted correctly in the list.
    - _Remedy:_ Use `Security.insertProviderAt()` to place a provider at the top of the list, or set a property in the Java config file.
- **Not using `getInstance()` correctly**: Specifying only the algorithm in `Cipher.getInstance()` will often use an insecure default, so always specify the mode of operation and the padding scheme.
    - _Remedy:_ Specify the full transformation string (e.g. `AES/GCM/NoPadding` instead of just "AES").
- **Failing to Use a Key Derivation Function**: Deriving keys directly from passwords without using a proper key derivation function, like PBKDF2 or Argon2.
    - _Remedy_: Use PBKDF2, Argon2, or a FIPS approved KDF to generate a key from a password and salt.
- **Ignoring Warnings:** Ignoring the warnings that are printed when generating weak keys, or using weak algorithms.
    - _Remedy:_ Review all warnings and take corrective action.
- **Not Properly Handling Exceptions**: Not properly handling exceptions when performing cryptographic operations can lead to unencrypted data being leaked or exposed.
    - _Remedy_: Always implement a proper error handling strategy, to ensure that cryptographic operations fail securely and don't leak information.
- **Storing passwords directly in database:** Instead of storing only a hash of the password, the password itself is stored in the database and can be exposed if the database is compromised.
    - _Remedy_: Always hash passwords with a strong password hash before storing in a database.
- **Trusting user provided input:** Not properly sanitizing the user provided input when constructing cryptographic operations can lead to unexpected and dangerous behavior.
    - _Remedy:_ Always validate, sanitize and encode all inputs.
- **Reusing Nonce:**
	- Reusing IVs in CBC mode, not using SecureRandom for key generation or using small key sizes.
- **Same Credentials for Authorization and Decryption**: 
	- If attacker gets authorization they will also be able to decrypt.

**Additional Auditor Notes**

- **Mixed FIPS/Non-FIPS:** Verify FIPS modules are used for _all_ relevant crypto operations and in the correct FIPS mode. Ensure non-FIPS modules are not being used for cryptography, or for security sensitive functions.
- **Runtime Checks:** FIPS modes are enabled at runtime. You need to check that FIPS mode is enabled as well as which crypto providers are being used.
